<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE language SYSTEM "klayout_doc.dtd">

<!-- generated by /home/matthias/klayout/dvb/scripts/extract_doc.rb  -->
<!-- DO NOT EDIT! -->

<doc>
<title>DRC Reference: Netter object</title>
<keyword name="Netter"/>
<p>
The Netter object provides services related to network extraction
from a layout. The relevant methods of this object are available
as global functions too where they act on a default incarnation
of the netter. Usually it's not required to instantiate a Netter
object, but it serves as a container for this functionality.
</p><p>
An individual netter object can be created, if the netter results
need to be kept for multiple extractions. If you really need
a Netter object, use the global <a href="#netter">netter</a> function:
</p><p>
<pre>
# create a new Netter object:
nx = netter
nx.connect(poly, contact)
...
</pre>
</p><p>
Network formation:
</p><p>
A basic Service the Netter object provides is the formation of 
connected networks of conductive shapes. To do so, the Netter
must be given a connection specification. This happens by calling
"connect" with two polygon layers. The Netter will then regard all
overlaps of shapes on these layers as connections between the
respective materials. Networks are the basis for netlist extraction,
network geometry deduction and the antenna check.
</p><p>
Connections can be cleared with "clear_connections". If not, 
connections add atop of the already defined ones. Here is an 
example for the antenna check:
</p><p>
<pre>
# build connction of poly+gate to metal1
connect(gate, poly)
connect(poly, contact)
connect(contact, metal1)

# runs an antenna check for metal1 with a ratio of 50
m1_antenna_errors = antenna_check(gate, metal1, 50.0)

# add connections to metal2
connect(metal1, via1)
connect(via1, metal2)

# runs an antenna check for metal2 with a ratio of 70.0
m2_antenna_errors = antenna_check(gate, metal2, 70.0)

# this will remove all connections made
clear_connections
...
</pre>
</p><p>
Further functionality of the Netter object:
</p><p>
More methods will be added in the future to support network-related features.
</p>
<h2-index/>
<h2>"antenna_check" - Performs an antenna check</h2>
<keyword name="antenna_check"/>
<a name="antenna_check"/><p>Usage:</p>
<ul>
<li><tt>antenna_check(gate, metal, ratio, [ diode_specs ... ])</tt></li>
</ul>
<p>
The antenna check is used to avoid plasma induced damage. Physically, 
the damage happes if during the manufacturing of a metal layer with
plasma etching charge accumulates on the metal islands. On reaching a
certain threshold, this charge may discarge over gate oxide attached of 
devices attached to such metal areas hence damaging it.
</p><p>
Antenna checks are performed by collecting all connected nets up to
a certain metal layer and then computing the area of all metal shapes
and all connected gates of a certain kind (e.g. thin and thick oxide gates).
The ratio of metal area divided by the gate area must not exceed a certain
threshold.
</p><p>
A simple antenna check is this:
</p><p>
<pre>
poly = ... # poly layer
diff = ... # diffusion layer
contact = ... # contact layer
metal1 = ... # metal layer

# compute gate area
gate = poly &amp; diff

# note that gate and poly have to be included - gate is
# a subset of poly, but forms the sensitive area
connect(gate, poly)
connect(poly, contact)
connect(contact, metal1)
errors = antenna_check(gate, metal1, 50.0)
</pre>
</p><p>
Plasma induced damage can be rectified by including diodes
which create a safe current path for discharging the metal
islands. Such diodes can be identified with a recognition layer
(usually the diffusion area of a certain kind). You can include
such diode recognition layers in the antenna check. If a connection
is detected to a diode, the respective network is skipped:
</p><p>
<pre>
...
diode = ... # diode recognition layer

connect(diode, contact)
errors = antenna_check(gate, metal1, 50.0, diode)
</pre>
</p><p>
You can also make diode connections decreases the
sensitivity of the antenna check depending on the size
of the diode. The following specification makes 
diode connections increase the ratio threshold by
10 per square micrometer of diode area:
</p><p>
<pre>
...
diode = ... # diode recognition layer

connect(diode, contact)
# each square micrometer of diode area connected to a network
# will add 10 to the ratio:
errors = antenna_check(gate, metal1, 50.0, [ diode, 10.0 ])
</pre>
</p><p>
Multiple diode specifications are allowed. Just add them 
to the antenna_check call.
</p><p>
The error shapes produced by the antenna check are a copy
of the metal shapes on the metal layers of each network 
violating the antenna rule.
</p>
<h2>"clear_connections" - Clears all connections stored so far</h2>
<keyword name="clear_connections"/>
<a name="clear_connections"/><p>Usage:</p>
<ul>
<li><tt>clear_connections</tt></li>
</ul>
<p>
See <a href="#connect">connect</a> for more details.
</p>
<h2>"connect" - Specifies a connection between two layers</h2>
<keyword name="connect"/>
<a name="connect"/><p>Usage:</p>
<ul>
<li><tt>connect(a, b)</tt></li>
</ul>
<p>
a and b must be polygon layers. After calling this function, the
Netter regards all overlapping or touching shapes on these layers
to form an electrical connection between the materials formed by
these layers. This also implies intra-layer connections: shapes
on these layers touching or overlapping other shapes on these
layers will form bigger, electrically connected areas.
</p><p>
Multiple connect calls must be made to form larger connectivity
stacks across multiple layers. Such stacks may include forks and
joins.
</p><p>
Connections are accumulated. The connections defined so far
can be cleared with <a href="#clear_connections">clear_connections</a>.
</p>
</doc>
